import { $mark, $inputRule } from '@milkdown/utils';
import { InputRule } from 'prosemirror-inputrules';
import store from '../../../store';

export const commentMark = $mark('comment', (ctx) => {
  return {
    inclusive: true,
    attrs: { 
      id: { default: null },
      resolved: { default: false }
    },
    parseDOM: [
      {
        tag: 'span[data-comment-id]',
        getAttrs: (dom) => {
          if (!(dom instanceof HTMLElement))
            throw expectDomTypeError(dom)

          return {
            id: dom?.getAttribute('data-comment-id') ?? null,
            resolved: dom?.getAttribute('data-resolved') === 'true' ?? false
          }
        },
      },
    ],
    toDOM: (mark) => [
      'span',
      {
        class: `comment-mark ${mark?.attrs?.resolved ? 'comment-resolved' : ''}`,
        ref: `comment-mark-${mark?.attrs?.id}`,
        'data-comment-id': mark?.attrs?.id,
        'data-resolved': mark?.attrs?.resolved?.toString(),
      },
      0,
    ],
    parseMarkdown: {
      match: (node) => {
        // Match text nodes that contain the comment pattern
        return node.type === 'textDirective' && node.name === 'comment';
      },
      runner: (state, node, markType) => {
        const id = node.attributes?.id || '';
        const resolved = node.attributes?.resolved === 'true';
        state.openMark(markType, {id, resolved});
        state.next(node.children[0]); // recurse into text inside
        state.closeMark(markType);
      },
    },
    toMarkdown: {
      match: (mark) => mark.type.name === 'comment',
      runner: (state, mark, node) => {
        state.withMark(mark, 'textDirective', undefined, { 
          name: 'comment', 
          attributes: { 
            id: mark.attrs.id,
            resolved: mark.attrs.resolved.toString()
          } });
      },
    },
  };
});

/**
 * Utility function to add a comment mark to text in the editor
 * This can be imported and used by other parts of the codebase (e.g., vertexAiService)
 * 
 * @param {Object} editorView - The ProseMirror editor view instance
 * @param {string} textToMark - The exact text to mark with the comment
 * @param {string} commentContent - The comment text content
 * @param {number} startPos - Optional starting position in the document (if not provided, will search for text)
 * @param {string} parentId - Optional parent comment ID for threaded comments
 * @param {string} versionId - Optional version ID for the comment
 * @param {boolean} aiGenerated - Optional boolean to indicate if the comment was generated by AI
 * @returns {boolean} - True if comment mark was successfully added, false otherwise
 */
export const addComment = async (editorView, textToMark, commentContent, startPos = null, parentId = null, versionId = null, aiGenerated = false) => {
  if (!editorView || !commentContent) {
    console.error('addComment: Missing required parameters');
    return false;
  }
  
  const commentData = {
    comment: commentContent,
    documentVersion: versionId || (store.state.selected.currentVersion === 'live' ? null : store.state.selected.currentVersion),
    selectedText: textToMark || '',
    parentId: parentId || null,
    resolved: false,
    aiGenerated: aiGenerated || false
  };

  try {
    const comment = await store.dispatch('addComment', commentData);

    // Try to add the comment mark to text, but don't fail if it doesn't work
    if (textToMark || startPos !== null) {
      const markSuccess = await addCommentMarkToText(editorView, textToMark, comment.id, startPos, comment.resolved);
      if (!markSuccess) {
        console.warn('addComment: Failed to add comment mark to text, but comment was created successfully');
      }
    }

    return true;
  } catch (error) {
    console.error('addComment: Error creating comment:', error);
    return false;
  }
}

export async function addCommentMarkToText(editorView, textToMark, commentId, startPos = null, resolved = false) {
  if (!editorView || !commentId) {
    console.error('addCommentMarkToText: Missing required parameters');
    return false;
  }

  const { state, dispatch } = editorView;
  const { schema } = state;
  const commentMarkType = schema.marks.comment;

  if (!commentMarkType) {
    console.error('addCommentMarkToText: Comment mark type not found in schema');
    return false;
  }

  let from = startPos;
  let to = startPos;

  // If startPos is provided, use it directly
  if (startPos !== null) {
    to = startPos + (textToMark ? textToMark.length : 0);
  } else if (textToMark) {
    // Try to find the text with flexible matching
    const found = findTextInDocument(state, textToMark);
    if (found) {
      from = found.from;
      to = found.to;
    } else {
      console.warn(`addCommentMarkToText: Could not find text "${textToMark}" in document. Comment will be created without text marking.`);
      // Return true to allow comment creation without text marking
      return true;
    }
  } else {
    console.warn('addCommentMarkToText: No text to mark and no position provided');
    return true;
  }

  // Check if there's already a comment mark in this range
  if (state.doc.rangeHasMark(from, to, commentMarkType)) {
    console.warn(`addCommentMarkToText: Comment mark already exists for range ${from}-${to}`);
    return false;
  }

  const commentMark = commentMarkType.create({ id: commentId, resolved });
  const transaction = state.tr.addMark(from, to, commentMark);

  if (dispatch) {
    dispatch(transaction);
  }

  console.log(`addCommentMarkToText: Successfully added comment mark for ID "${commentId}" at position ${from}-${to} (resolved: ${resolved})`);
  return true;
}

/**
 * Helper function to find text in document with flexible matching
 * @param {Object} state - ProseMirror state
 * @param {string} searchText - Text to search for
 * @returns {Object|null} - {from, to} positions or null if not found
 */
function findTextInDocument(state, searchText) {
  if (!searchText || !searchText.trim()) {
    return null;
  }

  const docText = state.doc.textContent;
  const normalizedSearchText = normalizeText(searchText);
  const normalizedDocText = normalizeText(docText);

  // Try exact match first
  let index = normalizedDocText.indexOf(normalizedSearchText);
  if (index !== -1) {
    const from = state.doc.resolve(index).pos;
    const to = state.doc.resolve(index + normalizedSearchText.length).pos;
    return { from, to };
  }

  // Try fuzzy matching (ignore case and extra whitespace)
  const fuzzySearchText = normalizedSearchText.toLowerCase().trim();
  const fuzzyDocText = normalizedDocText.toLowerCase();
  
  index = fuzzyDocText.indexOf(fuzzySearchText);
  if (index !== -1) {
    const from = state.doc.resolve(index).pos;
    const to = state.doc.resolve(index + fuzzySearchText.length).pos;
    return { from, to };
  }

  // Try finding the longest common substring
  const words = searchText.split(/\s+/).filter(word => word.length > 3);
  for (const word of words) {
    const normalizedWord = normalizeText(word);
    index = normalizedDocText.indexOf(normalizedWord);
    if (index !== -1) {
      const from = state.doc.resolve(index).pos;
      const to = state.doc.resolve(index + normalizedWord.length).pos;
      console.log(`addCommentMarkToText: Found partial match for word "${word}" at position ${from}-${to}`);
      return { from, to };
    }
  }

  return null;
}

/**
 * Helper function to normalize text for comparison
 * @param {string} text - Text to normalize
 * @returns {string} - Normalized text
 */
function normalizeText(text) {
  return text
    .replace(/\s+/g, ' ') // Replace multiple whitespace with single space
    .replace(/[\r\n\t]/g, ' ') // Replace line breaks and tabs with spaces
    .trim();
}

export async function resolveComment(editorView, commentId) {
  try{
    await store.dispatch('updateCommentData', {
      id: commentId,
      data: { resolved: true }
    });

    // Add a small delay to ensure the editor state is stable
    await new Promise(resolve => setTimeout(resolve, 100));

    updateCommentMarkResolved(editorView, commentId, true);

    store.commit('alert', {
        type: 'success',
        message: 'Comment resolved',
        autoClear: true
    });
    return true;
  } catch (error) {
    console.error('resolveComment: Error updating comment mark:', error);
    return false;
  }
}

export async function unresolveComment(editorView, commentId) {
  try{
    await store.dispatch('updateCommentData', {
      id: commentId,
      data: { resolved: false }
    });

    // Add a small delay to ensure the editor state is stable
    await new Promise(resolve => setTimeout(resolve, 100));

    updateCommentMarkResolved(editorView, commentId, false);

    store.commit('alert', {
        type: 'success',
        message: 'Comment unresolved',
        autoClear: true
    });
    return true;
  } catch (error) {
    console.error('unresolveComment: Error updating comment mark:', error);
    return false;
  }
}

export async function deleteComment(editorView, commentId) {
  try{
    await store.dispatch('deleteComment', commentId);
    await new Promise(resolve => setTimeout(resolve, 100));
    removeCommentMarkById(editorView, commentId);
    store.commit('alert', {
      type: 'success',
      message: 'Comment deleted',
      autoClear: true
    });
    return true;
  } catch (error) {
    console.error('deleteComment: Error deleting comment:', error);
    return false;
  }
}



/**
 * Utility function to remove a comment mark from text in the editor
 * 
 * @param {Object} editorView - The ProseMirror editor view instance
 * @param {string} commentId - The comment ID to remove
 * @returns {boolean} - True if comment mark was successfully removed, false otherwise
 */
export function removeCommentMarkById(editorView, commentId) {
  if (!editorView || !commentId) {
    console.error('removeCommentMarkById: Missing required parameters');
    return false;
  }

  const { state, dispatch } = editorView;
  const { schema } = state;
  const commentMarkType = schema.marks.comment;

  if (!commentMarkType) {
    console.error('removeCommentMarkById: Comment mark type not found in schema');
    return false;
  }

  try {
    // 1. Collect all ranges that contain the target mark.
    const ranges = [];

    state.doc.descendants((node, pos) => {
      if (!node.isText) return;
      node.marks.forEach(mark => {
        if (mark.type === commentMarkType && mark.attrs.id === commentId) {
          ranges.push({ from: pos, to: pos + node.nodeSize });
        }
      });
    });

    if (ranges.length === 0) {
      console.warn(`removeCommentMarkById: No comment mark found with ID "${commentId}"`);
      return false;
    }

    // 2. Remove marks using mapping so every subsequent range is remapped
    let tr = state.tr;
    ranges.forEach(({ from, to }) => {
      const mappedFrom = tr.mapping.map(from);
      const mappedTo   = tr.mapping.map(to);
      tr = tr.removeMark(mappedFrom, mappedTo, commentMarkType);
    });

    dispatch(tr);
    console.log(`removeCommentMarkById: Successfully removed comment mark with ID "${commentId}"`);
    return true;
  } catch (error) {
    console.error('removeCommentMarkById: Error applying transaction:', error);
    return false;
  }
}

export function scrollToCommentInEditor(commentId, editorView = null) {
    // If editorView is provided, use it to find the element within the editor
    if (editorView && editorView.dom) {
        const commentElement = editorView.dom.querySelector(`[data-comment-id="${commentId}"]`);
        if (commentElement) {
            // Find the scrollable container - the main content area
            const scrollContainer = document.querySelector('main[style*="overflow-y: auto"]') || 
                                  document.querySelector('.v-main') ||
                                  commentElement.closest('.ProseMirror') ||
                                  editorView.dom;
            
            if (scrollContainer && scrollContainer !== document.body) {
                // Calculate scroll position to center the comment element
                const containerRect = scrollContainer.getBoundingClientRect();
                const commentRect = commentElement.getBoundingClientRect();
                
                const scrollTop = scrollContainer.scrollTop + 
                    (commentRect.top - containerRect.top) - 
                    (containerRect.height / 2) + 
                    (commentRect.height / 2);
                
                // Scroll within the container
                scrollContainer.scrollTo({
                    top: scrollTop,
                    behavior: 'smooth'
                });
            } else {
                // Fallback to scrollIntoView if no suitable container found
                commentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            // Add a visual highlight effect
            commentElement.classList.add('comment-highlight');
            
            // Remove the highlight after a delay
            setTimeout(() => {
                commentElement.classList.remove('comment-highlight');
            }, 2000);
            
            return true;
        }
    } else {
        // Fallback: search the entire document for the comment element
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (commentElement) {
            // Find the scrollable container - the main content area
            const scrollContainer = document.querySelector('main[style*="overflow-y: auto"]') || 
                                  document.querySelector('.v-main') ||
                                  commentElement.closest('.ProseMirror');
            
            if (scrollContainer && scrollContainer !== document.body) {
                // Calculate scroll position to center the comment element
                const containerRect = scrollContainer.getBoundingClientRect();
                const commentRect = commentElement.getBoundingClientRect();
                
                const scrollTop = scrollContainer.scrollTop + 
                    (commentRect.top - containerRect.top) - 
                    (containerRect.height / 2) + 
                    (commentRect.height / 2);
                
                // Scroll within the container
                scrollContainer.scrollTo({
                    top: scrollTop,
                    behavior: 'smooth'
                });
            } else {
                // Fallback to scrollIntoView if no suitable container found
                commentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            // Add a visual highlight effect
            commentElement.classList.add('comment-highlight');
            
            // Remove the highlight after a delay
            setTimeout(() => {
                commentElement.classList.remove('comment-highlight');
            }, 2000);
            
            return true;
        }
    }
    
    console.warn(`scrollToCommentInEditor: No comment element found with ID "${commentId}"`);
    return false;
}

/**
 * Utility function to update the resolved state of a comment mark
 * 
 * @param {Object} editorView - The ProseMirror editor view instance
 * @param {string} commentId - The comment ID to update
 * @param {boolean} resolved - The new resolved state
 * @returns {boolean} - True if comment mark was successfully updated, false otherwise
 */
export function updateCommentMarkResolved(editorView, commentId, resolved) {
  if (!editorView || !commentId) {
    console.error('updateCommentMarkResolved: Missing required parameters');
    return false;
  }

  const { state, dispatch } = editorView;
  const { schema } = state;
  const commentMarkType = schema.marks.comment;

  if (!commentMarkType) {
    console.error('updateCommentMarkResolved: Comment mark type not found in schema');
    return false;
  }

  try {
    // Find all ranges that contain the target mark
    const ranges = [];
    state.doc.descendants((node, pos) => {
      if (!node.isText) return;
      node.marks.forEach(mark => {
        if (mark.type === commentMarkType && mark.attrs.id === commentId) {
          ranges.push({ from: pos, to: pos + node.nodeSize });
        }
      });
    });

    if (ranges.length === 0) {
      console.warn(`updateCommentMarkResolved: No comment mark found with ID "${commentId}"`);
      return false;
    }

    // Update marks using mapping so every subsequent range is remapped
    let tr = state.tr;
    ranges.forEach(({ from, to }) => {
      const mappedFrom = tr.mapping.map(from);
      const mappedTo = tr.mapping.map(to);
      
      // Remove the old mark
      tr = tr.removeMark(mappedFrom, mappedTo, commentMarkType);
      
      // Add the new mark with updated resolved state
      const newCommentMark = commentMarkType.create({ id: commentId, resolved });
      tr = tr.addMark(mappedFrom, mappedTo, newCommentMark);
    });

    dispatch(tr);
    return true;
  } catch (error) {
    console.error('updateCommentMarkResolved: Error applying transaction:', error);
    return false;
  }
}

// Add CSS styles for comment marks
const style = document.createElement('style');
style.textContent = `
  .comment-mark {
    background-color: rgba(255, 255, 0, 0.20) !important;
    border: 1px solid rgba(255, 255, 0, 0.50) !important;
    border-radius: 8px !important;
    padding: 1px 2px !important;
    cursor: pointer !important;
    transition: background-color 0.2s ease !important;
  }
  
  .comment-mark:hover {
    background-color: rgba(255, 255, 0, 0.35) !important;
  }
  
  .comment-mark.comment-resolved {
    background-color: rgba(76, 175, 80, 0.15) !important;
    border: 1px solid rgba(76, 175, 80, 0.40) !important;
    opacity: 0.7 !important;
    text-decoration: line-through !important;
  }
  
  .comment-mark.comment-resolved:hover {
    background-color: rgba(76, 175, 80, 0.25) !important;
  }
  
  .comment-highlight {
    background-color: rgba(255, 255, 0, 0.60) !important;
    border: 2px solid rgba(255, 255, 0, 0.80) !important;
    box-shadow: 0 0 8px rgba(255, 255, 0, 0.40) !important;
    transition: all 0.3s ease !important;
  }
`;
document.head.appendChild(style);