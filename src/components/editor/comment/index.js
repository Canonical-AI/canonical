import { $mark, $inputRule } from '@milkdown/utils';
import { InputRule } from 'prosemirror-inputrules';
import store from '../../../store';

export const commentMark = $mark('comment', (ctx) => {
  return {
    inclusive: false,
    attrs: { 
      id: { default: null }
    },
    parseDOM: [
      {
        tag: 'span[data-comment-id]',
        getAttrs: (dom) => ({
          id: dom.getAttribute('data-comment-id'),
        }),
      },
    ],
    toDOM: (mark) => [
      'span',
      {
        class: 'comment-mark',
        ref: `comment-mark-${mark.attrs.id}`,
        'data-comment-id': mark.attrs.id,
      },
      0,
    ],
    parseMarkdown: {
      match: (node) => {
        // Match text nodes that contain the comment pattern
        return node.type === 'textDirective' && node.name === 'comment';
      },
      runner: (state, node, markType) => {
        const id = node.attributes?.id || '';
        state.openMark(markType, {id});
        state.next(node.children[0]); // recurse into text inside
        state.closeMark(markType);
      },
    },
    toMarkdown: {
      match: (mark) => mark.type.name === 'comment',
      runner: (state, mark, node) => {
        state.withMark(mark, 'textDirective', undefined, { 
          name: 'comment', 
          attributes: { 
            id: mark.attrs.id 
          } });
      },
    },
  };
});

/**
 * Utility function to add a comment mark to text in the editor
 * This can be imported and used by other parts of the codebase (e.g., vertexAiService)
 * 
 * @param {Object} editorView - The ProseMirror editor view instance
 * @param {string} textToMark - The exact text to mark with the comment
 * @param {string} commentContent - The comment text content
 * @param {number} startPos - Optional starting position in the document (if not provided, will search for text)
 * @param {string} parentId - Optional parent comment ID for threaded comments
 * @param {string} versionId - Optional version ID for the comment
 * @param {boolean} aiGenerated - Optional boolean to indicate if the comment was generated by AI
 * @returns {boolean} - True if comment mark was successfully added, false otherwise
 */
export async function addCommentMarkToText(editorView, textToMark, commentContent, startPos = null, parentId = null, versionId = null, aiGenerated = false) {
  if (!editorView || !textToMark || !commentContent) {
    console.error('addCommentMarkToText: Missing required parameters');
    return false;
  }

  const { state, dispatch } = editorView;
  const { schema } = state;
  const commentMarkType = schema.marks.comment;

  if (!commentMarkType) {
    console.error('addCommentMarkToText: Comment mark type not found in schema');
    return false;
  }

  let from = startPos;
  let to = startPos;

  // If startPos is not provided, search for the text in the document
  if (startPos === null) {
    const docText = state.doc.textContent;
    const textIndex = docText.indexOf(textToMark);
    
    if (textIndex === -1) {
      console.error(`addCommentMarkToText: Text "${textToMark}" not found in document`);
      return false;
    }

    // Convert character index to position
    from = state.doc.resolve(textIndex).pos;
    to = state.doc.resolve(textIndex + textToMark.length).pos;
  } else {
    // Use provided startPos and calculate end position
    to = startPos + textToMark.length;
  }

  // Verify the text at the position matches what we expect
  const actualText = state.doc.textBetween(from, to);
  if (actualText !== textToMark) {
    console.error(`addCommentMarkToText: Text mismatch. Expected: "${textToMark}", Found: "${actualText}"`);
    return false;
  }

  // Check if there's already a comment mark in this range
  if (state.doc.rangeHasMark(from, to, commentMarkType)) {
    console.warn(`addCommentMarkToText: Comment mark already exists for text "${textToMark}"`);
    return false;
  }

  try {
    // Create the comment in the database first to get the comment ID
    const commentData = {
      comment: commentContent,
      documentVersion: versionId || (store.state.selected.currentVersion === 'live' ? null : store.state.selected.currentVersion),
      selectedText: textToMark,
      parentId: parentId || null,
      resolved: false,
      aiGenerated: aiGenerated || false
    };

    const comment = await store.dispatch('addComment', commentData);

    // Create and apply the comment mark with the database-generated ID
    const commentMark = commentMarkType.create({ id: comment.id });
    const transaction = state.tr.addMark(from, to, commentMark);
    
    if (dispatch) {
      dispatch(transaction);
    }

    console.log(`addCommentMarkToText: Successfully added comment mark for text "${textToMark}" with ID "${comment.id}"`);
    return true;
  } catch (error) {
    console.error('addCommentMarkToText: Failed to create comment in database:', error);
    return false;
  }
}

/**
 * Utility function to remove a comment mark from text in the editor
 * 
 * @param {Object} editorView - The ProseMirror editor view instance
 * @param {string} commentId - The comment ID to remove
 * @returns {boolean} - True if comment mark was successfully removed, false otherwise
 */
export function removeCommentMarkById(editorView, commentId) {
  if (!editorView || !commentId) {
    console.error('removeCommentMarkById: Missing required parameters');
    return false;
  }

  const { state, dispatch } = editorView;
  const { schema } = state;
  const commentMarkType = schema.marks.comment;

  if (!commentMarkType) {
    console.error('removeCommentMarkById: Comment mark type not found in schema');
    return false;
  }

  try {
    // Get the current state at the time of application
    const currentState = editorView.state;
    let transaction = currentState.tr;
    let found = false;

    // Find and remove all marks with the specified comment ID
    currentState.doc.descendants((node, pos) => {
      if (node.isText) {
        node.marks.forEach(mark => {
          if (mark.type === commentMarkType && mark.attrs.id === commentId) {
            transaction = transaction.removeMark(pos, pos + node.nodeSize, commentMarkType);
            found = true;
          }
        });
      }
    });

    if (!found) {
      console.warn(`removeCommentMarkById: No comment mark found with ID "${commentId}"`);
      return false;
    }

    // Apply the transaction
    if (dispatch) {
      dispatch(transaction);
      console.log(`removeCommentMarkById: Successfully removed comment mark with ID "${commentId}"`);
      return true;
    }
  } catch (error) {
    console.error('removeCommentMarkById: Error applying transaction:', error);
    return false;
  }

  return false;
}

export function scrollToCommentInEditor(commentId, editorView = null) {
    // If editorView is provided, use it to find the element within the editor
    if (editorView && editorView.dom) {
        const commentElement = editorView.dom.querySelector(`[data-comment-id="${commentId}"]`);
        if (commentElement) {
            // Find the scrollable container - the main content area
            const scrollContainer = document.querySelector('main[style*="overflow-y: auto"]') || 
                                  document.querySelector('.v-main') ||
                                  commentElement.closest('.ProseMirror') ||
                                  editorView.dom;
            
            if (scrollContainer && scrollContainer !== document.body) {
                // Calculate scroll position to center the comment element
                const containerRect = scrollContainer.getBoundingClientRect();
                const commentRect = commentElement.getBoundingClientRect();
                
                const scrollTop = scrollContainer.scrollTop + 
                    (commentRect.top - containerRect.top) - 
                    (containerRect.height / 2) + 
                    (commentRect.height / 2);
                
                // Scroll within the container
                scrollContainer.scrollTo({
                    top: scrollTop,
                    behavior: 'smooth'
                });
            } else {
                // Fallback to scrollIntoView if no suitable container found
                commentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            // Add a visual highlight effect
            commentElement.classList.add('comment-highlight');
            
            // Remove the highlight after a delay
            setTimeout(() => {
                commentElement.classList.remove('comment-highlight');
            }, 2000);
            
            return true;
        }
    } else {
        // Fallback: search the entire document for the comment element
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (commentElement) {
            // Find the scrollable container - the main content area
            const scrollContainer = document.querySelector('main[style*="overflow-y: auto"]') || 
                                  document.querySelector('.v-main') ||
                                  commentElement.closest('.ProseMirror');
            
            if (scrollContainer && scrollContainer !== document.body) {
                // Calculate scroll position to center the comment element
                const containerRect = scrollContainer.getBoundingClientRect();
                const commentRect = commentElement.getBoundingClientRect();
                
                const scrollTop = scrollContainer.scrollTop + 
                    (commentRect.top - containerRect.top) - 
                    (containerRect.height / 2) + 
                    (commentRect.height / 2);
                
                // Scroll within the container
                scrollContainer.scrollTo({
                    top: scrollTop,
                    behavior: 'smooth'
                });
            } else {
                // Fallback to scrollIntoView if no suitable container found
                commentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            // Add a visual highlight effect
            commentElement.classList.add('comment-highlight');
            
            // Remove the highlight after a delay
            setTimeout(() => {
                commentElement.classList.remove('comment-highlight');
            }, 2000);
            
            return true;
        }
    }
    
    console.warn(`scrollToCommentInEditor: No comment element found with ID "${commentId}"`);
    return false;
}

// Add CSS styles for comment marks
const style = document.createElement('style');
style.textContent = `
  .comment-mark {
    background-color: rgba(255, 255, 0, 0.20) !important;
    border: 1px solid rgba(255, 255, 0, 0.50) !important;
    border-radius: 8px !important;
    padding: 1px 2px !important;
    cursor: pointer !important;
    transition: background-color 0.2s ease !important;
  }
  
  .comment-mark:hover {
    background-color: rgba(255, 255, 0, 0.35) !important;
  }
  
  .comment-highlight {
    background-color: rgba(255, 255, 0, 0.60) !important;
    border: 2px solid rgba(255, 255, 0, 0.80) !important;
    box-shadow: 0 0 8px rgba(255, 255, 0, 0.40) !important;
    transition: all 0.3s ease !important;
  }
`;
document.head.appendChild(style);